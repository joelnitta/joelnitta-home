{
  "hash": "21d49147d03c36c9cecf8bb480698117",
  "result": {
    "markdown": "---\ntitle: \"Selecting color schemes for mapping ancestral states\"\ndescription:\n  How to change the phytools default color scheme when visualizing the results of ancestral character state estimation\ndate: \"2021-06-02\"\nimage: featured.png\nexecute:\n  echo: true\n  cache: false\n  messages: false\n  warning: false\ncitation:\n  url: https://www.joelnitta.com/posts/2021-06-02_color-scheme-anc-states/\ncategories:\n  - r\n  - plotting\n---\n\n\n## About `contMap()`\n\nThe `phytools` package provides (among many other things) the [`contMap()`](https://rdrr.io/cran/phytools/man/contMap.html) function for estimating ancestral character states and [visualizing their changes along the branches of a phylogenetic tree](http://blog.phytools.org/search?q=contmap). It can either produce the plot directly (default), or be saved as an object with the `plot = FALSE` argument, to be further manipulated and plotted later with `plot()`.\n\n## Default colors\n\nI have to say I'm not a fan of the default color scheme, which is a rainbow palette going from red through yellow and green to blue. \n\nFor example, let's [borrow some example code](http://www.phytools.org/eqg2015/asr.html) and look at the default plot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# code modified slightly from http://www.phytools.org/eqg2015/asr.html\n\n## Load needed packages for this blogpost\nlibrary(phytools)\nlibrary(ggtree)\nlibrary(tidyverse)\nlibrary(scico)\nlibrary(viridisLite)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Load anole tree\nanole.tree <- read.tree(\"http://www.phytools.org/eqg2015/data/anole.tre\")\n\n## Load anole trait data, extract snout-vent-length (svl) as named vector\nsvl <- read_csv(\"http://www.phytools.org/eqg2015/data/svl.csv\") %>%\n  mutate(svl = set_names(svl, species)) %>%\n  pull(svl)\n\n# Plot with default color scheme\ncontmap_obj <- contMap(anole.tree, svl, plot = FALSE)\n\nplot(\n  contmap_obj, \n  type=\"fan\", \n  legend = 0.7*max(nodeHeights(anole.tree)),\n  fsize = c(0.5, 0.7))\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Default rainbow color scheme. Pretty, but confusing.](index.ja_files/figure-html/fig-plot-contmap-default-hide-1.png){#fig-plot-contmap-default-hide width=672}\n:::\n:::\n\n\nAlthough this does provide a wide range of colors, **it's not obvious why one color is greater or less than the others**. In particular it's hard to discern the order of intermediate values (yellow, green, light blue). Indeed, there has been much written on [why the rainbow palette is generally not a good way to visualize continuous data](https://www.nature.com/articles/s41467-020-19160-7).\n\n## Defining a new color palette\n\n[`phytools::setMap()`](https://rdrr.io/cran/phytools/man/setMap.html) can be used to specify another color palette. `setMap()` passes its second argument (a vector of color names or [hexadecimals](https://en.wikipedia.org/wiki/Web_colors)) to [`colorRampPalette()`](https://rdrr.io/r/grDevices/colorRamp.html). `colorRampPalette()` is a bit unusual in that it's a function that produces a function, in this case, one that generates a vector of colors interpolating between the original input values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# colorRampPalette() produces a function\nmy_color_func <- colorRampPalette(c(\"red\", \"yellow\"))\nclass(my_color_func)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"function\"\n```\n:::\n\n```{.r .cell-code}\n# The function generates n colors interpolating between\n# the colors originally passed to colorRampPalette()\nmy_colors <- my_color_func(n = 6)\nscales::show_col(my_colors)\n```\n\n::: {.cell-output-display}\n![A red-to-yellow color ramp.](index.ja_files/figure-html/fig-colorRampPalette-1.png){#fig-colorRampPalette width=672}\n:::\n:::\n\n\nSo, this works fine for generating custom color gradients. But [designing accurate, color-blind friendly color palettes is not a simple task](https://www.fabiocrameri.ch/visualisation/). Fortunately, there are several packages available with such carefully crafted palettes. Two of my favorite are [`viridis`](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html) and [`scico`](https://github.com/thomasp85/scico). **How can we use these with the plotting function in phytools?**\n\n## Using `viridis` or `scico` palettes\n\nWell, it turns out that as long as we specify the same number of colors, we can replicate the viridis color palette with `colorRampPalette()`. The only difference is the alpha, or transparency level, indicated at the [end of each hexidecimal with two letters](https://stackoverflow.com/questions/23201134/transparent-argb-hex-value) (here \"FF\"). There is no reason to use transparency here anyways, so that doesn't matter.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# viridis color palette with 6 colors\nviridis(6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"#440154FF\" \"#414487FF\" \"#2A788EFF\" \"#22A884FF\" \"#7AD151FF\" \"#FDE725FF\"\n```\n:::\n\n```{.r .cell-code}\n# colorRampPalette() replicating viridis color palette\ncolorRampPalette(viridis(6))(6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"#440154\" \"#414487\" \"#2A788E\" \"#22A884\" \"#7AD151\" \"#FDE725\"\n```\n:::\n:::\n\n\nSo here is the `viridis` version of the phytools plot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Count the number of unique character states in the observed data:\nn_cols <- n_distinct(svl)\n\n# Change the color palette\ncontmap_obj_viridis <- setMap(contmap_obj, viridis(n_cols))\n\n# Plot the mapped characters with the new colors\nplot(\n  contmap_obj_viridis, \n  type=\"fan\", \n  legend = 0.7*max(nodeHeights(anole.tree)),\n  fsize = c(0.5, 0.7))\n```\n\n::: {.cell-output-display}\n![Viridis colors. Better.](index.ja_files/figure-html/fig-phytools-viridis-1.png){#fig-phytools-viridis width=672}\n:::\n:::\n\n\nAnd here is another one, this time using a palette from `scico`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Change the color palette\ncontmap_obj_scico <- setMap(contmap_obj, scico(n_cols, palette = \"bilbao\"))\n\n# Plot the mapped characters with the new colors\nplot(\n  contmap_obj_scico, \n  type=\"fan\", \n  legend = 0.7*max(nodeHeights(anole.tree)),\n  fsize = c(0.5, 0.7))\n```\n\n::: {.cell-output-display}\n![Scico colors. My personal favorite.](index.ja_files/figure-html/fig-phytools-scico-1.png){#fig-phytools-scico width=672}\n:::\n:::\n\n\nI personally find this one even easier to interpret than `viridis`. It's very clear which values are low and high.\n\n## `ggtree`\n\nJust for completeness, here is code to replicate the plot in  [`ggtree`](https://github.com/YuLab-SMU/ggtree).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Modified from https://yulab-smu.top/treedata-book/chapter4.html#color-tree\n\n# Fit an ancestral state character reconstruction\nfit <- phytools::fastAnc(anole.tree, svl, vars = TRUE, CI = TRUE)\n\n# Make a dataframe with trait values at the tips\ntd <- data.frame(\n  node = nodeid(anole.tree, names(svl)),\n  trait = svl)\n\n# Make a dataframe with estimated trait values at the nodes\nnd <- data.frame(node = names(fit$ace), trait = fit$ace)\n\n# Combine these with the tree data for plotting with ggtree\nd <- rbind(td, nd)\nd$node <- as.numeric(d$node)\ntree <- full_join(anole.tree, d, by = 'node')\n\nggtree(\n  tree, \n  aes(color = trait), \n  layout = 'circular', \n  ladderize = FALSE, continuous = \"color\", size = 1) +\n  # >>> The important part! <<<\n  # Choose your favorite scale_color_* function here: \n  scale_color_scico(palette = \"bilbao\") + \n  geom_tiplab(hjust = -.1, size = 2, color = \"black\") + \n  xlim(0, 1.2) + \n  theme(\n    legend.position = c(0, .82),\n    legend.text = element_text(size = 8),\n    legend.title = element_text(size = 8)\n  ) \n```\n\n::: {.cell-output-display}\n![Scico colors with ggtree.](index.ja_files/figure-html/fig-plot-contmap-ggtree-1.png){#fig-plot-contmap-ggtree width=672}\n:::\n:::\n\n\nThat's it!\n",
    "supporting": [
      "index.ja_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}